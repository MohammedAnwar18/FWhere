<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Earth Style (Hand Controlled)</title>

    <!-- Mapbox GL JS -->
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.1.2/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.1.2/mapbox-gl.css' rel='stylesheet' />

    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: sans-serif;
        }

        #map {
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 100;
            pointer-events: none;
        }

        #status-box {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 12px 20px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-family: monospace;
            text-align: center;
            min-width: 250px;
        }

        #cam-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            background: #111;
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid #555;
            display: none;
        }

        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.8;
        }

        #output-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        button {
            pointer-events: auto;
            background: linear-gradient(135deg, #10b981, #3b82f6);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 50px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 200, 100, 0.4);
        }

        .mapboxgl-ctrl-logo,
        .mapboxgl-ctrl-attrib {
            display: none !important;
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <div id="status-box">Ready - Click Start</div>
        <button id="start-btn">START CAMERA</button>
    </div>

    <div id="cam-container">
        <video id="input-video" playsinline></video>
        <canvas id="output-canvas"></canvas>
    </div>

    <div id="map"></div>

    <script>
        // --- 1. MAPBOX SETUP WITH GOOGLE TILES ---
        mapboxgl.accessToken = 'pk.eyJ1IjoibW9oYW1tZWQtMTMzMSIsImEiOiJjbWlsaWh1anAxM2kzM2dyNHR5eTU4am9hIn0.arsZikWNpuoceyWdnM30VA';

        const map = new mapboxgl.Map({
            container: 'map',
            projection: 'globe',
            style: {
                version: 8,
                sources: {
                    // Actual Google Satellite Tiles
                    'google-satellite': {
                        type: 'raster',
                        tiles: ['https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}'],
                        tileSize: 256
                    },
                    // Mapbox DEM for 3D Terrain
                    'mapbox-dem': {
                        type: 'raster-dem',
                        url: 'mapbox://mapbox.mapbox-terrain-dem-v1',
                        tileSize: 512,
                        maxzoom: 14
                    }
                },
                layers: [
                    {
                        id: 'google-satellite-layer',
                        type: 'raster',
                        source: 'google-satellite',
                        paint: {}
                    }
                ]
            },
            zoom: 1.5,
            center: [30, 20],
            pitch: 0
        });

        map.on('style.load', () => {
            // Enable 3D Terrain
            map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });

            // Add Atmosphere
            map.setFog({
                'range': [0.5, 10],
                'color': 'white',
                'horizon-blend': 0.1,
                'star-intensity': 0.8
            });
        });


        // --- 2. SMART GESTURE LOGIC ---

        // State
        let state = {
            mode: 'IDLE', // IDLE, MOVE, ZOOM_IN, ZOOM_OUT, STOP
            velocity: { bearing: 0, pitch: 0, zoom: 0 },
            smoothness: 0.05 // Lower = Smoother/Slower
        };

        function animate() {
            requestAnimationFrame(animate);
            if (!map) return;

            // 1. Friction / Smoothing (Decay momentum if no input)
            if (state.mode === 'STOP') {
                // Hard Stop
                state.velocity.bearing = 0;
                state.velocity.pitch = 0;
                state.velocity.zoom = 0;
            }

            // 2. Apply velocities to Map
            const currentBearing = map.getBearing();
            const currentPitch = map.getPitch();
            const currentZoom = map.getZoom();

            // Rotate (Bearing)
            if (Math.abs(state.velocity.bearing) > 0.001) {
                map.easeTo({
                    bearing: currentBearing + state.velocity.bearing,
                    pitch: currentPitch + state.velocity.pitch,
                    zoom: currentZoom + state.velocity.zoom,
                    duration: 0, // Instant update for continuous feel
                    easing: t => t
                });
            } else if (Math.abs(state.velocity.zoom) > 0.001) {
                // Zoom only update
                map.easeTo({
                    zoom: currentZoom + state.velocity.zoom,
                    duration: 0,
                    easing: t => t
                });
            }
        }
        animate();


        // --- 3. MEDIAPIPE HANDS WITH SMART DETECTION ---
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const statusBox = document.getElementById('status-box');

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 2 });
                drawLandmarks(canvasCtx, landmarks, { color: '#00FFFF', lineWidth: 1 });

                // --- HEURISTICS ---
                const wrist = landmarks[0];
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];

                // 1. Detect FIST (Stop)
                // Check if all fingertips are close to the wrist (curled)
                const tips = [indexTip, middleTip, ringTip, pinkyTip];
                const avgDistToWrist = tips.reduce((sum, tip) => sum + Math.hypot(tip.x - wrist.x, tip.y - wrist.y), 0) / 4;
                const isFist = avgDistToWrist < 0.35; // Threshold for closed hand

                // 2. Detect PINCH (Zoom Out)
                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                const isPinch = pinchDist < 0.06;

                // 3. Detect OPEN HAND (Zoom In)
                // Fingers extended and thumb far from index
                const isOpen = !isFist && !isPinch && pinchDist > 0.15;


                // --- CONTROL MAPPING ---

                // A. Hand Position (Direction)
                // Center is (0.5, 0.5)
                const handX = landmarks[9].x; // Use Middle finger MCP (palm centerish)
                const handY = landmarks[9].y;

                const deadzone = 0.1; // 10% deadzone in center
                let dirX = (handX - 0.5);
                let dirY = (handY - 0.5);

                // Apply Deadzone
                if (Math.abs(dirX) < deadzone) dirX = 0;
                else dirX = Math.sign(dirX) * (Math.abs(dirX) - deadzone);

                if (Math.abs(dirY) < deadzone) dirY = 0;
                else dirY = Math.sign(dirY) * (Math.abs(dirY) - deadzone);


                let statusText = "";
                let statusColor = "#fff";

                if (isFist) {
                    // --- STOP MODE ---
                    state.mode = 'STOP';
                    statusText = "ðŸ›‘ FIST DETECTED: STOPPING";
                    statusColor = "#ff4444";

                } else if (isPinch) {
                    // --- ZOOM OUT MODE ---
                    state.mode = 'ZOOM_OUT';
                    state.velocity.zoom = -0.02; // Slow constant zoom out
                    state.velocity.bearing = -dirX * 0.5; // Allow rotation while zooming
                    state.velocity.pitch = 0;

                    statusText = "ðŸ¤ PINCH: ZOOMING OUT";
                    statusColor = "#ffff00";

                } else if (isOpen) {
                    // --- ZOOM IN MODE ---
                    state.mode = 'ZOOM_IN';
                    state.velocity.zoom = 0.02; // Slow constant zoom in
                    state.velocity.bearing = -dirX * 0.5; // Allow rotation
                    state.velocity.pitch = dirY * 0.5;    // Allow tilt

                    statusText = "ðŸ– OPEN HAND: ZOOMING IN";
                    statusColor = "#00ff00";

                } else {
                    // --- NAVIGATION MODE (Neutral) ---
                    // Just move around without zooming
                    state.mode = 'MOVE';
                    state.velocity.zoom = 0;

                    // X controls Bearing (Rotate)
                    // Y controls Pitch (Tilt Up/Down)
                    state.velocity.bearing = -dirX * 0.8; // Negative to invert natural feel (drag map) or positive to fly? 
                    // Let's use: Hand Right -> Camera Rotates Right (Bearing increases? No, Bearing decreases rotates map LEFT). 
                    // Actually comfortable: Hand Right -> Look Right.
                    state.velocity.pitch = dirY * 1.0;

                    statusText = `âœˆï¸ NAVIGATING`;
                    if (dirX === 0 && dirY === 0) statusText = "âš“ HOVERING (Center Hand)";
                }

                statusBox.innerText = statusText;
                statusBox.style.color = statusColor;
                statusBox.style.borderColor = statusColor;

            } else {
                state.mode = 'IDLE';
                state.velocity = { bearing: 0, pitch: 0, zoom: 0 };
                statusBox.innerText = "NO HAND FOUND";
                statusBox.style.color = "#888";
                statusBox.style.borderColor = "#444";
            }
            canvasCtx.restore();
        }

        // Camera Start
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        document.getElementById('start-btn').addEventListener('click', async () => {
            document.getElementById('start-btn').style.display = 'none';
            statusBox.innerText = "Loading Camera...";

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
                videoElement.srcObject = stream;
                await videoElement.play();

                document.getElementById('cam-container').style.display = 'block';
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;

                const cameraLoop = async () => {
                    await hands.send({ image: videoElement });
                    requestAnimationFrame(cameraLoop);
                };
                cameraLoop();
            } catch (e) {
                alert("Camera Error: " + e.message);
                statusBox.innerText = "Camera Failed";
            }
        });
    </script>
</body>

</html>
